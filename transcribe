#!/usr/bin/env python
import os
import time
import logging
from pathlib import Path
from dotenv import load_dotenv
from google import genai
from google.genai import types

load_dotenv()

API_KEY = os.getenv("GEMINI_API_KEY")
if not API_KEY:
    raise ValueError("Error: GEMINI_API_KEY not found in .env file.")

BASE_AUDIO_DIR = "audio"
BASE_SUBS_DIR = "subs"

# Setup logging
logging.basicConfig(
    filename="transcribe.log",
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s"
)

client = genai.Client(api_key=API_KEY)
MODEL_NAME = "gemini-2.5-flash"

def transcribe_file(file_path, max_retries=3):
    """
    Uploads an audio file to Gemini, requests a transcription,
    and returns the text. Retries on failure.
    """
    # Map file extensions to mime types
    mime_types = {
        '.mp3': 'audio/mpeg',
        '.wav': 'audio/wav',
        '.m4a': 'audio/mp4',
        '.aac': 'audio/aac',
        '.flac': 'audio/flac',
        '.ogg': 'audio/ogg',
    }
    ext = Path(file_path).suffix.lower()
    mime_type = mime_types.get(ext, 'application/octet-stream')

    for attempt in range(1, max_retries + 1):
        msg = f"Transcribing {file_path} (Attempt {attempt})..."
        print(msg)
        logging.info(msg)
        try:
            # Read audio file and create Part directly
            with open(file_path, "rb") as f:
                audio_data = f.read()
            
            # Create Part with inline data
            audio_part = types.Part(
                inline_data=types.Blob(
                    mime_type=mime_type,
                    data=audio_data
                )
            )
            
            msg = f"Processing transcription for {file_path.name}..."
            print(msg)
            logging.info(msg)
            # Prepare markdown title (exclude video_id)
            base_name = file_path.stem.replace('_', ' ')
            # Remove trailing video_id if present (last token after space is likely video_id)
            tokens = base_name.split()
            # YouTube video IDs are 11 characters, alphanumeric, sometimes with _ or -
            import re
            video_id_pattern = re.compile(r'^[A-Za-z0-9_-]{11}$')
            if tokens and video_id_pattern.match(tokens[-1]):
                title_text = ' '.join(tokens[:-1])
            else:
                title_text = base_name
            title = f"# {title_text}\n\n"
            # Prompt Gemini to format transcript with paragraphs and markdown, using only the cleaned title
            response = client.models.generate_content(
                model=MODEL_NAME,
                contents=[
                    audio_part,
                    (
                        f"Transcribe this audio file into markdown format. "
                        f"Use the following as the title: '{title_text}'. "
                        "Write the transcript as paragraphs, using natural breaks where a new paragraph is needed. "
                        "Do not add timestamps or speaker labels. Output only markdown, and do not repeat the title."
                    )
                ]
            )
            msg = f"Transcription successful for {file_path}"
            print(msg)
            logging.info(msg)
            # Only add the title once, and ensure transcript does not repeat it
            transcript = response.text.strip()
            # Remove duplicate title if Gemini includes it
            if transcript.startswith(title.strip()):
                transcript = transcript[len(title.strip()):].lstrip('\n')
            markdown = title + transcript + '\n'
            return markdown
        except Exception as e:
            err_msg = f"Error transcribing {file_path} on attempt {attempt}: {e}"
            print(err_msg)
            logging.error(err_msg)
            if attempt < max_retries:
                time.sleep(5)
            else:
                logging.error(f"Max retries reached for {file_path}. Skipping.")
                print(f"Max retries reached for {file_path}. Skipping.")
    return None

def main():
    audio_extensions = {'.mp3', '.wav', '.m4a', '.aac', '.flac', '.ogg'}
    msg = f"Scanning '{BASE_AUDIO_DIR}' for audio files..."
    print(msg)
    logging.info(msg)
    processed_one = False
    for root, dirs, files in os.walk(BASE_AUDIO_DIR):
        for file in files:
            file_path = Path(root) / file
            if file_path.suffix.lower() in audio_extensions:
                relative_path = file_path.relative_to(BASE_AUDIO_DIR)
                output_path = Path(BASE_SUBS_DIR) / relative_path.with_suffix('.md')
                output_path.parent.mkdir(parents=True, exist_ok=True)
                if output_path.exists():
                    msg = f"Skipping {file_path.name} (Transcript already exists)"
                    print(msg)
                    logging.info(msg)
                    continue
                transcript = transcribe_file(file_path)
                if transcript:
                    with open(output_path, "w", encoding="utf-8") as f:
                        f.write(transcript)
                    msg = f"Saved: {output_path}"
                    print(msg)
                    logging.info(msg)
                else:
                    err_msg = f"Failed to transcribe {file_path}"
                    print(err_msg)
                    logging.error(err_msg)
                processed_one = True
                break
        if processed_one:
            break

if __name__ == "__main__":
    main()