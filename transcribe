#!/usr/bin/env python
import os
import sys
import time
import logging
from pathlib import Path
from dotenv import load_dotenv
from google import genai
from google.genai import types

load_dotenv()

API_KEY = os.getenv("GEMINI_API_KEY")
if not API_KEY:
    raise ValueError("Error: GEMINI_API_KEY not found in .env file.")

BASE_AUDIO_DIR = "audio"
BASE_SUBS_DIR = "subs"
BASE_MD_DIR = "md"

# API rate limiting (seconds between API calls)
API_DELAY = 2  # Adjust this value based on your API tier

# Setup logging
logging.basicConfig(
    filename="transcribe.log",
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s"
)

client = genai.Client(api_key=API_KEY)
MODEL_NAME = "gemini-2.5-flash"

def transcribe_file_simple(file_path, max_retries=3):
    """
    Uploads an audio file to Gemini and returns a simple transcription.
    """
    # Map file extensions to mime types
    mime_types = {
        '.mp3': 'audio/mpeg',
        '.wav': 'audio/wav',
        '.m4a': 'audio/mp4',
        '.aac': 'audio/aac',
        '.flac': 'audio/flac',
        '.ogg': 'audio/ogg',
    }
    ext = Path(file_path).suffix.lower()
    mime_type = mime_types.get(ext, 'application/octet-stream')

    for attempt in range(1, max_retries + 1):
        msg = f"Transcribing {file_path} (Attempt {attempt})..."
        print(msg)
        logging.info(msg)
        try:
            with open(file_path, "rb") as f:
                audio_data = f.read()
            
            audio_part = types.Part(
                inline_data=types.Blob(
                    mime_type=mime_type,
                    data=audio_data
                )
            )
            
            msg = f"Processing transcription for {file_path.name}..."
            print(msg)
            logging.info(msg)
            
            response = client.models.generate_content(
                model=MODEL_NAME,
                contents=[
                    audio_part,
                    "Transcribe this audio file accurately."
                ]
            )
            
            msg = f"Transcription successful for {file_path}"
            print(msg)
            logging.info(msg)
            # Add delay to respect API rate limits
            time.sleep(API_DELAY)
            return response.text.strip()
        except Exception as e:
            err_msg = f"Error transcribing {file_path} on attempt {attempt}: {e}"
            print(err_msg)
            logging.error(err_msg)
            
            # Check for rate limit errors
            error_str = str(e).lower()
            if 'rate limit' in error_str or 'quota' in error_str or '429' in error_str:
                wait_time = 60  # Wait 60 seconds for rate limit errors
                print(f"Rate limit detected. Waiting {wait_time} seconds...")
                logging.warning(f"Rate limit hit. Waiting {wait_time} seconds.")
                time.sleep(wait_time)
            elif attempt < max_retries:
                time.sleep(5)
            
            if attempt >= max_retries:
                logging.error(f"Max retries reached for {file_path}. Skipping.")
                print(f"Max retries reached for {file_path}. Skipping.")
    return None

def convert_to_markdown(transcript, file_path, max_retries=3):
    """
    Converts a plain transcript to structured markdown format using Gemini.
    """
    import re
    # Prepare markdown title (exclude video_id)
    base_name = file_path.stem.replace('_', ' ')
    video_id_pattern = re.compile(r'^[A-Za-z0-9_-]{11}$')
    tokens = base_name.split()
    # Remove last token if it matches video_id pattern
    if tokens and video_id_pattern.match(tokens[-1]):
        title_text = ' '.join(tokens[:-1])
    else:
        # Also check if last token after removing underscores matches
        base_name_no_underscore = file_path.stem.replace('_', '')
        if video_id_pattern.match(base_name_no_underscore[-11:]):
            title_text = base_name[:-12].rstrip()
        else:
            title_text = base_name
    
    for attempt in range(1, max_retries + 1):
        msg = f"Converting to markdown for {file_path.name} (Attempt {attempt})..."
        print(msg)
        logging.info(msg)
        try:
            response = client.models.generate_content(
                model=MODEL_NAME,
                contents=[
                    f"Convert this transcript into a clean, structured Markdown study note. "
                    f"Use the title: '# {title_text}'.\n\n"
                    "**Strict Editing Rules for AI Optimization:**\n"
                    "1. **Executive Summary:** Start with a bulleted 'Executive Summary' of the 3-5 key scientific findings.\n"
                    "2. **Remove Visual References:** Delete phrases like 'black circles', 'as shown in the right panel', or 'you can see here'. Describe the data trend directly instead (e.g., 'The data shows a 50% increase').\n"
                    "3. **Format Protocols as Lists:** If the speaker describes a step-by-step protocol (like exercise routines or study methodology), format it as a clear bulleted list.\n"
                    "4. **Standardize Terms:** Replace 'lit mice' with 'Little (dwarf) mice' throughout. Ensure chemical names are spelled correctly.\n"
                    "5. **Delete Meta-Commentary:** Remove intros, outros, Patreon plugs, or calls to leave comments. Keep only the scientific data.\n"
                    "6. **Structure:** Use H2 headings (##) for major scientific topics (e.g., 'Mouse Data', 'Human Evidence').\n"
                    "7. **Visualizing Processes:** If a complex biological process is described (like a metabolic pathway), create a text-based flowchart using arrows ( -> ) to visualize the steps.\n\n"
                    f"Transcript:\n{transcript}"
                ]
            )
            msg = f"Markdown conversion successful for {file_path}"
            print(msg)
            logging.info(msg)
            # Add delay to respect API rate limits
            time.sleep(API_DELAY)
            return response.text.strip() + '\n'
        except Exception as e:
            err_msg = f"Error converting to markdown for {file_path} on attempt {attempt}: {e}"
            print(err_msg)
            logging.error(err_msg)
            
            # Check for rate limit errors
            error_str = str(e).lower()
            if 'rate limit' in error_str or 'quota' in error_str or '429' in error_str:
                wait_time = 60  # Wait 60 seconds for rate limit errors
                print(f"Rate limit detected. Waiting {wait_time} seconds...")
                logging.warning(f"Rate limit hit. Waiting {wait_time} seconds.")
                time.sleep(wait_time)
            elif attempt < max_retries:
                time.sleep(5)
            
            if attempt >= max_retries:
                logging.error(f"Max retries reached for {file_path}. Skipping.")
                print(f"Max retries reached for {file_path}. Skipping.")
    return None

def main():
    audio_extensions = {'.mp3', '.wav', '.m4a', '.aac', '.flac', '.ogg'}
    msg = f"Scanning '{BASE_AUDIO_DIR}' for audio files..."
    print(msg)
    logging.info(msg)
    for root, dirs, files in os.walk(BASE_AUDIO_DIR):
        for file in files:
            file_path = Path(root) / file
            if file_path.suffix.lower() in audio_extensions:
                relative_path = file_path.relative_to(BASE_AUDIO_DIR)

                # First, create simple transcription in subs/ folder
                subs_output_path = Path(BASE_SUBS_DIR) / relative_path.with_suffix('.txt')
                subs_output_path.parent.mkdir(parents=True, exist_ok=True)

                transcript = None
                if not subs_output_path.exists():
                    transcript = transcribe_file_simple(file_path)
                    if transcript:
                        with open(subs_output_path, "w", encoding="utf-8") as f:
                            f.write(transcript)
                        msg = f"Saved simple transcription: {subs_output_path}"
                        print(msg)
                        logging.info(msg)
                    else:
                        err_msg = f"Failed to transcribe {file_path}"
                        print(err_msg)
                        logging.error(err_msg)
                        continue
                else:
                    msg = f"Simple transcription already exists for {file_path.name}"
                    print(msg)
                    logging.info(msg)
                    # Read transcript for markdown conversion
                    with open(subs_output_path, "r", encoding="utf-8") as f:
                        transcript = f.read()

                # Second, create markdown version in md/ folder
                md_output_path = Path(BASE_MD_DIR) / relative_path.with_suffix('.md')
                md_output_path.parent.mkdir(parents=True, exist_ok=True)

                if not md_output_path.exists():
                    if transcript:
                        markdown = convert_to_markdown(transcript, file_path)
                        if markdown:
                            with open(md_output_path, "w", encoding="utf-8") as f:
                                f.write(markdown)
                            msg = f"Saved markdown: {md_output_path}"
                            print(msg)
                            logging.info(msg)
                        else:
                            err_msg = f"Failed to create markdown for {file_path}"
                            print(err_msg)
                            logging.error(err_msg)
                    else:
                        err_msg = f"No transcript available for markdown conversion: {file_path}"
                        print(err_msg)
                        logging.error(err_msg)
                else:
                    msg = f"Markdown already exists for {file_path.name}"
                    print(msg)
                    logging.info(msg)

if __name__ == "__main__":
    main()