#!/usr/bin/env python
import os
import asyncio
import httpx
import time
import random
from deepgram import DeepgramClient, PrerecordedOptions, FileSource

# Lowered to 3 for better stability across 1,700 files
semaphore = asyncio.Semaphore(3)

# Deepgram 2026 Rates
BASE_RATE_PER_MIN = 0.0058
DIARIZE_ADDON = 0.0020
TOTAL_RATE_PER_SEC = (BASE_RATE_PER_MIN + DIARIZE_ADDON) / 60

async def get_balance(api_key):
    try:
        async with httpx.AsyncClient() as client:
            headers = {"Authorization": f"Token {api_key}"}
            p_resp = await client.get("https://api.deepgram.com/v1/projects", headers=headers)
            project_id = p_resp.json()["projects"][0]["project_id"]
            b_resp = await client.get(f"https://api.deepgram.com/v1/projects/{project_id}/balances", headers=headers)
            return b_resp.json()["balances"][0]["amount"]
    except:
        return None

async def transcribe_file(client, in_path, out_path, idx, total, api_key):
    async with semaphore:
        filename = os.path.basename(in_path)
        
        # RETRY LOOP: 3 Attempts per file
        for attempt in range(1, 4):
            try:
                print(f"ðŸš€ [{idx}/{total}] Starting: {filename} (Attempt {attempt})")
                start_time = time.time()
                
                with open(in_path, "rb") as file:
                    buffer_data = file.read()
                    payload: FileSource = { "buffer": buffer_data }
                    options = PrerecordedOptions(
                        model="nova-2", 
                        smart_format=True, 
                        diarize=True
                    )
                    
                    response = await client.listen.asyncrest.v("1").transcribe_file(payload, options)
                    
                    duration_sec = response.metadata.duration
                    cost = duration_sec * TOTAL_RATE_PER_SEC
                    
                    os.makedirs(os.path.dirname(out_path), exist_ok=True)
                    with open(out_path, "w") as f:
                        f.write(response.results.channels[0].alternatives[0].transcript)
                    
                    print(f"âœ… Finished: {filename} (${cost:.4f})")
                    
                    # Periodic balance check
                    if idx % 5 == 0:
                        bal = await get_balance(api_key)
                        if bal: print(f"ðŸ’° BALANCE: ${bal:.2f}")
                    
                    return # Success - exit retry loop

            except Exception as e:
                error_detail = getattr(e, 'message', getattr(e, 'body', str(e)))
                
                if attempt < 3:
                    # Exponential backoff: 5s, 10s, 20s... with jitter
                    wait = (5 * (2 ** (attempt - 1))) + random.uniform(0, 1)
                    print(f"âš ï¸  Error on {filename}: {error_detail}. Retrying in {wait:.1f}s...")
                    await asyncio.sleep(wait)
                else:
                    print(f"âŒ FINAL FAILURE: {filename}: {error_detail}")
                    with open("deepgram_errors.log", "a") as log:
                        log.write(f"{in_path}: {error_detail}\n")

async def main():
    api_key = os.environ.get("DEEPGRAM_API_KEY")
    client = DeepgramClient(api_key)
    audio_root, out_root = "./audio", "./deepgram"
    file_queue = []

    for root, _, files in os.walk(audio_root):
        for f in files:
            if f.lower().endswith(('.m4a', '.mp3', '.wav', '.ogg')):
                in_p = os.path.join(root, f)
                rel_path = os.path.relpath(root, audio_root)
                out_p = os.path.join(out_root, rel_path, os.path.splitext(f)[0] + ".txt")
                if not os.path.exists(out_p):
                    file_queue.append((in_p, out_p))

    total = len(file_queue)
    print(f"ðŸ“‚ Found {total} files. Balance: ${await get_balance(api_key) or '???'}")

    # STAGGERED START: Launch files with a 1-second gap
    for i, (in_p, out_p) in enumerate(file_queue, 1):
        asyncio.create_task(transcribe_file(client, in_p, out_p, i, total, api_key))
        await asyncio.sleep(1) # This prevents the initial "burst" crash

    # Keep main alive until all tasks finish
    while len([t for t in asyncio.all_tasks() if t.get_name().startswith('Task-')]) > 1:
        await asyncio.sleep(5)

if __name__ == "__main__":
    asyncio.run(main())