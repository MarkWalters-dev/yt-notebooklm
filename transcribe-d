#!/usr/bin/env python
import os
import asyncio
import httpx
import time
import random
import sys
from deepgram import DeepgramClient, DeepgramClientOptions, PrerecordedOptions, FileSource

# Processing one at a time is mandatory for 100MB+ files on standard uploads
semaphore = asyncio.Semaphore(1)
SIZE_LIMIT_MB = 50

# Deepgram 2026 Rates
BASE_RATE_PER_MIN = 0.0058
DIARIZE_ADDON = 0.0020
TOTAL_RATE_PER_SEC = (BASE_RATE_PER_MIN + DIARIZE_ADDON) / 60

async def get_balance(api_key):
    PROJECT_ID = "d4ca0521-f43d-4694-8042-57f54eb57031"
    try:
        async with httpx.AsyncClient(timeout=15.0) as client:
            headers = {"Authorization": f"Token {api_key}"}
            b_resp = await client.get(f"https://api.deepgram.com/v1/projects/{PROJECT_ID}/balances", headers=headers)
            return b_resp.json()["balances"][0]["amount"]
    except:
        return None

async def transcribe_file(client, in_path, out_path, idx, total, api_key):
    async with semaphore:
        filename = os.path.basename(in_path)
        file_size_bytes = os.path.getsize(in_path)
        file_size_mb = file_size_bytes / (1024 * 1024)

        # SIZE LIMIT CHECK
        if file_size_mb > SIZE_LIMIT_MB:
            print(f"‚è© Skipping: {filename} ({file_size_mb:.1f} MB exceeds {SIZE_LIMIT_MB} MB limit)")
            with open("skipped_large_files.log", "a") as log:
                log.write(f"{in_path} | {file_size_mb:.1f} MB\n")
            return

        for attempt in range(1, 4):
            try:
                print(f"üöÄ [{idx}/{total}] Uploading: {filename} ({file_size_mb:.1f} MB)")
                
                with open(in_path, "rb") as file:
                    buffer_data = file.read()
                    payload: FileSource = { "buffer": buffer_data }
                    options = PrerecordedOptions(model="nova-2", smart_format=True, diarize=True)
                    
                    response = await client.listen.asyncrest.v("1").transcribe_file(payload, options)
                    
                    duration_sec = response.metadata.duration
                    cost = duration_sec * TOTAL_RATE_PER_SEC
                    
                    os.makedirs(os.path.dirname(out_path), exist_ok=True)
                    with open(out_path, "w") as f:
                        f.write(response.results.channels[0].alternatives[0].transcript)
                    
                    print(f"‚úÖ Finished: {filename} (${cost:.4f})")
                    return 

            except Exception as e:
                error_type = type(e).__name__
                if attempt < 3:
                    wait = 5 * attempt
                    print(f"‚ö†Ô∏è  {error_type} on {filename}. Retry {attempt}/3 in {wait}s...")
                    await asyncio.sleep(wait)
                else:
                    print(f"‚ùå FINAL FAILURE: {filename}: {error_type}")
                    with open("deepgram_errors.log", "a") as log:
                        log.write(f"{in_path} | {error_type}\n")

async def main():
    api_key = os.environ.get("DEEPGRAM_API_KEY")
    if not api_key:
        print("‚ùå Error: DEEPGRAM_API_KEY not found.")
        sys.exit(1)

    # 10-minute timeout for the massive uploads
    config = DeepgramClientOptions(options={"timeout": 600})
    client = DeepgramClient(api_key, config)
    
    audio_root, out_root = "./audio", "./deepgram"
    file_queue = []

    for root, _, files in os.walk(audio_root):
        for f in files:
            if f.lower().endswith(('.m4a', '.mp3', '.wav', '.ogg')):
                in_p = os.path.join(root, f)
                rel_path = os.path.relpath(root, audio_root)
                out_p = os.path.join(out_root, rel_path, os.path.splitext(f)[0] + ".txt")
                if not os.path.exists(out_p):
                    file_queue.append((in_p, out_p))

    print(f"üìÇ Queue: {len(file_queue)} files. Balance: ${await get_balance(api_key) or '???'}")

    try:
        for i, (in_p, out_p) in enumerate(file_queue, 1):
            await transcribe_file(client, in_p, out_p, i, len(file_queue), api_key)
            if i % 2 == 0:
                bal = await get_balance(api_key)
                if bal: print(f"üí∞ CURRENT BALANCE: ${bal:.2f}")

    except KeyboardInterrupt:
        print("\n\nüõë User interrupted. Shutting down gracefully...")
        # Closing the client explicitly if possible
        sys.exit(0)

if __name__ == "__main__":
    asyncio.run(main())