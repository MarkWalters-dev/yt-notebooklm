#!/usr/bin/env python
import os
import asyncio
import httpx
import time
# FIX: Only import these 3. DeepgramClient handles the rest.
from deepgram import DeepgramClient, PrerecordedOptions, FileSource

# Concurrency: 5 files at once is safe
semaphore = asyncio.Semaphore(5)

# Deepgram 2026 Rates
BASE_RATE_PER_MIN = 0.0058
DIARIZE_ADDON = 0.0020
TOTAL_RATE_PER_SEC = (BASE_RATE_PER_MIN + DIARIZE_ADDON) / 60

async def get_balance(api_key):
    try:
        async with httpx.AsyncClient() as client:
            headers = {"Authorization": f"Token {api_key}"}
            p_resp = await client.get("https://api.deepgram.com/v1/projects", headers=headers)
            project_id = p_resp.json()["projects"][0]["project_id"]
            b_resp = await client.get(f"https://api.deepgram.com/v1/projects/{project_id}/balances", headers=headers)
            return b_resp.json()["balances"][0]["amount"]
    except:
        return None

async def transcribe_file(client, in_path, out_path, idx, total, api_key):
    async with semaphore:
        filename = os.path.basename(in_path)
        print(f"üöÄ [{idx}/{total}] Starting: {filename}")
        
        try:
            start_time = time.time()
            with open(in_path, "rb") as file:
                buffer_data = file.read()
                # Ensure the payload is formatted exactly as the SDK expects
                payload: FileSource = { "buffer": buffer_data }
                options = PrerecordedOptions(
                    model="nova-2", 
                    smart_format=True, 
                    diarize=True
                )
                
                # FIX: In v3.x, use the 'await' keyword with the standard client.
                # This is the line that was likely failing your execution.
                response = await client.listen.rest.v("1").transcribe_file(payload, options)
                
                duration_sec = response.metadata.duration
                cost = duration_sec * TOTAL_RATE_PER_SEC
                process_time = time.time() - start_time
                
                os.makedirs(os.path.dirname(out_path), exist_ok=True)
                with open(out_path, "w") as f:
                    f.write(response.results.channels[0].alternatives[0].transcript)
                
                print(f"‚úÖ Finished: {filename} (${cost:.4f})")

                if idx % 10 == 0:
                    bal = await get_balance(api_key)
                    if bal is not None:
                        print(f"üí∞ REMAINING CREDIT: ${bal:.2f}")

        except Exception as e:
            print(f"‚ùå Error on {filename}: {e}")
            with open("deepgram_errors.log", "a") as log:
                log.write(f"{in_path}: {str(e)}\n")

async def main():
    api_key = os.environ.get("DEEPGRAM_API_KEY")
    if not api_key:
        print("‚ùå Error: DEEPGRAM_API_KEY not set.")
        return

    # Initialize the standard Client (it handles async internally)
    client = DeepgramClient(api_key)
    audio_root, out_root = "./audio", "./deepgram"
    file_queue = []

    for root, _, files in os.walk(audio_root):
        for f in files:
            if f.lower().endswith(('.m4a', '.mp3', '.wav', '.ogg')):
                in_p = os.path.join(root, f)
                rel_path = os.path.relpath(root, audio_root)
                out_p = os.path.join(out_root, rel_path, os.path.splitext(f)[0] + ".txt")
                if not os.path.exists(out_p):
                    file_queue.append((in_p, out_p))

    total = len(file_queue)
    print(f"üìÇ Found {total} files. Initial Balance: ${await get_balance(api_key) or '???'}")

    tasks = [transcribe_file(client, in_p, out_p, i, total, api_key) 
             for i, (in_p, out_p) in enumerate(file_queue, 1)]
    
    await asyncio.gather(*tasks)
    print("\nüèÅ ALL TASKS COMPLETE.")

if __name__ == "__main__":
    asyncio.run(main())